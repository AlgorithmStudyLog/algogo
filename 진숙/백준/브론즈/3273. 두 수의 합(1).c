#include <stdio.h>
#include <stdlib.h>

int main(){
    int n = 0;                  // 수열의 크기 = 배열의 크기
    int x = 0;                  // ai + aj = x 의 기준이 될 x 값
    int cnt = 0;                // 쌍의 개수를 저장할 변수
    int count[2000000] = {0};   // 사용한 값 확인을 위한 배열

    // 입력 받기
    scanf("%d", &n);

    int* arr = (int*)malloc(n * sizeof(int));   // n만큼 동적 할당
    if (arr == NULL){                           // 메모리 할당 실패 대비
        return 1;
    }

    for(int i = 0; i < n; i++){
        scanf("%d", &arr[i]);   
        count[arr[i]] = 1;
    }   
    scanf("%d", &x);

    // 확인
    for(int i = 0; i < n; i++){
        int idx = x - arr[i];
        if(idx > 0 && count[idx] == 1) cnt++;
    }

    // 출력
    printf("%d", cnt/2);

    // 동적 할당 해제
    free(arr);
    return 0;
}

/*
1. 2중 for문 - 시간 초과❌
2. 사용된 정수 체크하는 방식 - 런타임 에러(out of bound)❌
 * 입력받은 정수를 담은 arr, 개수 확인하는 count 모두 배열의 크기가 커서 발생한 것으로 추측
3. 정렬하고 이진 탐색 사용하기 - 시간 초과❌
4. 사용된 정수 체크하는 방식 다시 사용하되, 입력받은 정수에 관련된 배열 arr를 동적 할당 - 성공⭕️
 * 메모리(9192KB) 엄청 사용함 다른 방법 없을까
 * 그리고 쌍을 이루기 때문에, 둘 다 확인하고 나누기 2 하는건 비효율적인데 어떻게 하면 좋으려나
5. main함수 내부와 외부에서 사용가능한 메모리 차이가 있대. 전역변수로 2번 방식 사용하면 런타임 에러 안나려나? - 성공⭕️
 * 메모리(12832KB) 사용함. 아래에 GPT설명 참고
6. 재미있는 다른 사람 코드(5284KB) - [참고] 3273. 두 수의 합(2)  
    a. 입력 받은 값을 오름차순으로 정렬
    b. while문을 사용, 인덱스로 사용할 left, right 선언
        b-1. left = 0, right는 n-1로 초기화, while문 조건은 left < right  
    c. 배열의 첫번째 요소(가장 작은 수)와 마지막 요소를 더한 값을 기준 값(x)과 비교
        c-1. 더한 값이 기준 값보다 크면, left와 쌍을 이루는 값이 더 작아야하는 거니까 right-1
        c-2. 더한 값이 기준 값과 동일하면, left와 right는 쌍을 이루므로 다음 요소에 접근할 수 있도록 left+1, right-1, cnt+1
        c-3. 더한 값이 기준 값보다 작으면, 배열 안에 쌍을 이루는 값이 없으므로 다음 요소에 접근할 수 있도록 left+1
    d. cnt 출력
*/






/*
`main 함수 내부`와 `외부`(전역 변수 영역)에서 **메모리 사용 가능 공간의 차이**는 C 언어의 **메모리 구조(메모리 세그먼트 구조)** 때문.

## 💡 C 프로그램의 메모리 구조
C 프로그램은 실행 시 다음과 같은 메모리 세그먼트 구조를 따라.
```
+-----------------+
|   Stack         | ← 함수 내부 지역 변수 (main 내부 포함)
|-----------------|
|   Heap          | ← malloc 등 동적 할당
|-----------------|
|   BSS Segment   | ← 초기화되지 않은 전역/정적 변수(BSS = Block Started by Symbol)
|-----------------|
|   Data Segment  | ← 초기화된 전역/정적 변수
|-----------------|
|   Text Segment  | ← 실행 코드 (함수 코드 등)
+-----------------+
```

---

## 📌 차이의 핵심: **스택(Stack)** vs **데이터 영역(Data Segment)**

| 구분 | main 함수 내부 (`int arr[1000000]`) | main 함수 외부 (`int arr[1000000]` 전역) |
|------|--------------------------------------|--------------------------------------------|
| 위치 | **스택** 영역                        | **데이터(BSS 또는 Data)** 영역             |
| 크기 제한 | **제한적** (보통 수 MB 수준)       | **상대적으로 큼** (수십~수백 MB 가능)       |
| 특징 | 함수가 호출될 때 메모리 할당됨          | 프로그램 시작 시 할당, 전역적으로 접근 가능 |
| 에러 | 크면 **stack overflow (out of bounds)** | 거의 없음 (충분한 메모리 있다면)           |

---

## ✅ 정리하자면!

- `main()` 안에 큰 배열을 선언하면 **스택 메모리를 초과해서 런타임 에러**가 발생할 수 있어.  
  예: `int arr[1000000];` → **약 4MB**  
  스택 크기가 제한되어 있어서 OS가 막아버림.

- 반면, `main()` 밖에서 배열을 선언하면 **전역 변수**가 되어 데이터 세그먼트에 저장되고,  
  이 영역은 **크기가 상대적으로 크기 때문에** 문제가 잘 안 생김.

---

## ✅ 해결 방법

- 스택 오버플로우 방지하려면:
  - `전역 변수`로 선언하거나
  - `malloc()`으로 `heap` 영역에 동적 할당하면 돼!
---

*/